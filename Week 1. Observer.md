****`JAVA Observer Pattern`****
****************************************************************************************************

# Observer


#### 옵저버 패턴의 정의

  - 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다
    메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴

  - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의한다.
  - 일대다 관계는 주제와 옵저버에 의해 정의되고 옵저버는 주제에 의존합니다.



****************************************************************************************************

# 옵저버 패턴의 구조

■ Subject Interface
- 주제를 나타내는 주제 인터페이스
- 객체에서 옵저버를 등록하거나 옵저버 무리에서 탈퇴하고 싶을때 사용하는 메서드들이 있음.
- 예를 들어 registerObserver(), removeObserver(), notifyObserver() 등이 있을 수 있음.
- 각 주제마다 여러개의 옵저버가 있을 수 있다.




■ Observer Interface
  - 옵저버거 될 가능성이 있는 객체는 반드시 Observer 인터페이스를 구현해야 한다.
  - 이 인터페이스는 주제의 상태가 바뀌었을 때 호출되는 update()메소드가 있다.

 

■ ConcreteSubject Class

  - Subject Interface를 구현하는 주제 클래스.
  - 옵저버 객체의 등록, 탈퇴, 상태변경 알림을 위한 메서드를 구현한다.
  - 주제 클래스는 상태를 설정하고 알아내기 위한 세터/게터 메서드가 들어있을 수도 있다.
 
■ ConcreteObserver Class

- Observer 인터페이스가 구현된 인터페이스를 뜻한다.
- Observer 인터페이스의 update()메서드만 구현되있다면 무엇이든 옵저버 클래스가 될 수 있다.
- 특정 주제 객체에 등록을 해서 notify로 알려주는 연락을 받을 수 있는 자격이 있다.

****************************************************************************************************

# 옵저버 패턴의 장점

■ 느슨한 결합을 제공한다.
- 주제가 옵저버에 대해 아는 것은 옵저버가 특정 인터페이스를 구현한다는 것 뿐이다. 다른 것을 알 필요가 없다.
- 옵저버는 언제든지 새로 추가할 수 있다. 주제는 옵저버 인터페이스를 구현하는 객체의 목록에만 의존하기 때문에 옵저버를 새로 추가하고 제거하기가 용이하다.
- 주제와 옵저버는 서로 독립적으로 사용할 수 있다. 단단히 결합되어있지 않기 때문에 손쉽게 재사용 할 수 있다.
- 주제가 옵저버가 바뀌더라도 서로에게 영향을 주지 않는다.
****************************************************************************************************
